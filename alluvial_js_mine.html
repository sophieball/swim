<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>test Visualisation</title>
    <script type="text/javascript" src="http://d3js.org/d3.v2.js"></script>
    <style type="text/css">
body {
    margin: 1em;
}
    
.node {
  stroke: #fff;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
  opacity: .3;
}
.link.on {
  stroke: #F00;
  opacity: .7;
}

.node {
    stroke: none;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">
    
/* Make Fake Data */

var num_cols = ["n0", "n1", "n2", "n3", "n4"];
var dest_cols = ["src", "dest1", "dest2", "dest3", "dest4"];
d3.csv("traffic_r.csv", function(data) {
    data.forEach(function(d) {
        num_cols.forEach(function(num) { d[num] = +d[num] });
        //d.n0 = +d.n0;
    });
    //console.log(data[0]["dest1"]);

    var times = []; // all nodes
    var allLinks = []; // links between cols
    var counter = 0;

    //generate nodes for one col
    function addNodes(names, values, links) {
        var ncount = names.length; // number of nodes in this col
        var nodes = d3.range(0, ncount).map(function(n) {
            return {
                id: counter++,
                nodeName: names[n],
                nodeValue: values[names[n]],
                incoming: [],
                link: links[names[n]], //links coming out
                linkCount: Object.keys(links[names[n]]).length
            }
        });
        times.push(nodes);
        return nodes;
    }

    function addNext(names, values, links, t) {
        if (t == 0) {
            addNodes(names, values, links);
            return;
        }
        var current = times[times.length - 1]; // an array of last col's nodes
        var nextt = addNodes(names, values, links, counter);

        current.forEach(function(n) {
            var linkCount = n.linkCount;
            var target, link, x;
            for (x = 0; x < linkCount; x++) {
                link = {
                    source: n.id,
                    target: Object.keys(n.link)[x], // how to get the id????
                    value: n.link[x]
                };
                allLinks.push(link);
            }
        })
    }

    function parse_data() {
        var maxt = num_cols.length, t = 0;

        for (t = 0; t < maxt; t++) {
            var values = {}, links = {}, linkCounts = {}, names = [],  i; 
            //find unique names in this col
            for(i = 0; i < data.length; i++) {
                if(typeof(values[data[i][dest_cols[t]]]) == "undefined") {
                    values[data[i][dest_cols[t]]] = data[i][num_cols[t]];
                    links[data[i][dest_cols[t]]] = {};
                    links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t]];
                } 
                else {
                    values[data[i][dest_cols[t]]] += data[i][num_cols[t]];
                    if (typeof(links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]]) == "undefined") {
                        links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t]];
                    }
                    else {
                        links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] += data[i][num_cols[t]];
                    }
                }
            }

            //sort by values in descending order
            names = Object.keys(values).sort(function(a,b){return values[b]-values[a]}); 

            addNext(names, values, links, t);
        }
        return {
                times: times,
                links: allLinks
        };
        
    }

//======
    function gen_data(names, values) {
            var maxt = num_cols.length, //col, # of time stamps
                maxn = 12,
                maxl = 4,
                maxv = 10,
                times = [],
                allLinks = [],
                counter = 0,
                // generate nodes for one col
                addNodes = function(t) {
                    var ncount = 4;//node count
                        nodes = d3.range(0, ncount).map(function(n) {
                            return {
                                id: counter++,
                                nodeName: data[n][dest_cols[t]],//names[counter++],
                                nodeValue: 0,
                                incoming: []
                            }
                        });
                    times.push(nodes);
                    return nodes;
                },
                addNext = function(t) {
                    var current = times[times.length-1],
                        nextt = addNodes(t);//next col of nodes
                    // make links
                    current.forEach(function(n) {
                        var linkCount = Math.min(~~(Math.random() * maxl + 1), nextt.length), //number of links coming out of nodes
                            breaks = d3.range(linkCount-1)
                                .map(function() { return Math.random() * n.nodeValue })//subitem portion
                                .sort(d3.ascending),
                            links = {},
                            target, link, x;
                        for (x=0; x<linkCount; x++) {
                            do { 
                                target = nextt[~~(Math.random() * nextt.length)];
                            } while (target.id in links);
                            // add link
                            link = {
                                source: n.id,
                                target: target.id,
                                value: (breaks[x] || n.nodeValue) - (breaks[x-1] || 0)
                            };
                            links[target.id] = link;
                            allLinks.push(link);
                            target.nodeValue += link.value;
                        }
                    });
                    // prune next
                    times[times.length-1] = nextt.filter(function(n) { return n.nodeValue });
                }
            // initial set
            addNodes(0).forEach(function(n) {
                n.nodeValue = values[n.id];//Math.random() * maxv + 1;
            });
            // now add rest
            for (var t=0; t<maxt-1; t++) {
                addNext(t+1);
            }
            
            return {
                times: times,
                links: allLinks
            };
        }



    names = ["a", "b", "c", "d", "a", "b", "c", "d", "a", "b", "c", "d", "a", "b", "c", "d"]
    values = [3,2,4,2,5,3,6,4,7,3,4,2,5,4,7,4]
    //var data = gen_data(names, values);
    var data = parse_data();
    console.log(data);

    /* Process Data */
        
    // make a node lookup map
    var nodeMap = (function() {
        var nm = {};
        data.times.forEach(function(nodes) {
            nodes.forEach(function(n) {
                nm[n.id] = n;
                // add links and assure node value
                n.links = [];
                n.incoming = [];
                n.nodeValue = n.nodeValue || 0;
            })
        });
        return nm;
    })();

    // attach links to nodes
    data.links.forEach(function(link) {
        nodeMap[link.source].links.push(link);
        nodeMap[link.target].incoming.push(link);
    });
        
    // sort by value and calculate offsets
    data.times.forEach(function(nodes) {
        var cumValue = 0;
        nodes.sort(function(a,b) {
            return d3.descending(a.nodeValue, b.nodeValue)
        });
        nodes.forEach(function(n, i) {
            n.order = i;
            n.offsetValue = cumValue;
            cumValue += n.nodeValue;
            // same for links
            var lCumValue;
            // outgoing
            if (n.links) {
                lCumValue = 0;
                n.links.sort(function(a,b) {
                    return d3.descending(a.value, b.value)
                });
                n.links.forEach(function(l) {
                    l.outOffset = lCumValue;
                    lCumValue += l.value;
                });
            }
            // incoming
            if (n.incoming) {
                lCumValue = 0;
                n.incoming.sort(function(a,b) {
                    return d3.descending(a.value, b.value)
                });
                n.incoming.forEach(function(l) {
                    l.inOffset = lCumValue;
                    lCumValue += l.value;
                });
            }
        })
    });
    data = data.times;

    // calculate maxes
    var maxn = d3.max(data, function(t) { return t.length }),
        maxv = d3.max(data, function(t) { return d3.sum(t, function(n) { return n.nodeValue }) });

    /* Make Vis */
        
    // settings and scales
    var w = 1400,
        h = 500,
        gapratio = .7,
        delay = 1500,
        padding = 15,
        x = d3.scale.ordinal()
            .domain(d3.range(data.length))
            .rangeBands([0, w + (w/(data.length-1))], gapratio),
        y = d3.scale.linear()
            .domain([0, maxv])
            .range([0, h - padding * maxn]),
        line = d3.svg.line()
            .interpolate('basis');
            
    // root
    var vis = d3.select("body")
      .append("svg:svg")
        .attr("width", w)
        .attr("height", h);
        
        
    var t = 0;
    function update(first) {
        // update data
        var currentData = data.slice(0, ++t);
        
        // time slots
        var times = vis.selectAll('g.time')
            .data(currentData)
          .enter().append('svg:g')
            .attr('class', 'time')
            .attr("transform", function(d, i) { return "translate(" + (x(i) - x(0)) + ",0)" });
            
        // node bars
        var nodes = times.selectAll('g.node')
            .data(function(d) { return d })
          .enter().append('svg:g')
            .attr('class', 'node');
        
        setTimeout(function() {
            nodes.append('svg:rect')
                .attr('fill', 'steelblue')
                .attr('y', function(n, i) {
                    return y(n.offsetValue) + i * padding;
                })
                .attr('width', x.rangeBand())
                .attr('height', function(n) { return y(n.nodeValue) })
              .append('svg:title')
                .text(function(n) { return "node: ".concat(n.nodeName).concat(" value: ").concat(n.nodeValue) });
        }, (first ? 0 : delay));
            
        var linkLine = function(start) {
            return function(l) {
                var source = nodeMap[l.source],
                    target = nodeMap[l.target],
                    gapWidth = x(0),
                    bandWidth = x.rangeBand() + gapWidth,
                    startx = x.rangeBand() - bandWidth,
                    sourcey = y(source.offsetValue) + 
                        source.order * padding +
                        y(l.outOffset) +
                        y(l.value)/2,
                    targety = y(target.offsetValue) + 
                        target.order * padding + 
                        y(l.inOffset) +
                        y(l.value)/2,
                    points = start ? 
                        [
                            [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ] 
                        ] :
                        [
                            [ startx, sourcey ],
                            [ startx + gapWidth/2, sourcey ],
                            [ startx + gapWidth/2, targety ],
                            [ 0, targety ]
                        ];
                return line(points);
            }
        }
            
        // links
        var links = nodes.selectAll('path.link')
            .data(function(n) { return n.incoming || [] })
          .enter().append('svg:path')
            .attr('class', 'link')
            .style('stroke-width', function(l) { return y(l.value) })
            .attr('d', linkLine(true))
            .on('mouseover', function() {
                d3.select(this).attr('class', 'link on')  
                .append("svg:title")
                    .text(function(t) { return t.value })
            })
            .on('mouseout', function() {
                d3.select(this).attr('class', 'link')
            })
          .transition()
            .duration(delay)
            .attr('d', linkLine());
            
    }

    function updateNext() {
        if (t < data.length) {
            update();
            window.setTimeout(updateNext, delay)
        }
    }
    update(true);
    updateNext();
  
});
    
    </script>
  </body>
</html>
