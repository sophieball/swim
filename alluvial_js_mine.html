<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <title>test Visualisation</title>
    <script type="text/javascript" src="http://d3js.org/d3.v2.js"></script>
    <style type="text/css">
body {
    margin: 1em;
}
    
.node {
  stroke: #fff;
  stroke-width: 2px;
}

.link {
  fill: none;
  stroke: #000;
  opacity: .3;
}
.link.on {
  stroke: #F00;
  opacity: .7;
}

.node {
    stroke: none;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">
    
/* Make Fake Data */

var num_cols = ["n0", "n1", "n2", "n3", "n4"];
var dest_cols = ["src", "dest1", "dest2", "dest3", "dest4"];
d3.csv("traffic_r.csv", function(data) {
    data.forEach(function(d) {
        num_cols.forEach(function(num) { d[num] = +d[num] });
        //d.n0 = +d.n0;
    });
    //console.log(data[0]["dest1"]);

    var times = []; // all nodes
    var allLinks = []; // links between cols
    var counter = 0;

    function parse_data() {
        var maxt = num_cols.length, t = 0;

        for (t = 0; t < maxt; t++) {//col
            var values = {}, links = {}, nextLinks = {}, names = [],  i; 

            //find unique names in this col
            for(i = 0; i < data.length; i++) {//row
                if(typeof(values[data[i][dest_cols[t]]]) == "undefined") {
                    values[data[i][dest_cols[t]]] = data[i][num_cols[t]];
                    links[data[i][dest_cols[t]]] = {};
                    links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t]];
                    if(t < maxt - 1) {
                        nextLinks[data[i][dest_cols[t]]] = {};
                        nextLinks[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t + 1]];
                    }
                } 
                else {
                    values[data[i][dest_cols[t]]] += data[i][num_cols[t]];
                    if (typeof(links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]]) == "undefined") {
                        links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t]];
                    
                        if(t < maxt - 1) {
                            nextLinks[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] = data[i][num_cols[t + 1]];
                        }
                    }
                    else {
                        links[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] += data[i][num_cols[t]];

                        if(t < maxt - 1) {
                            nextLinks[data[i][dest_cols[t]]][data[i][dest_cols[t + 1]]] += data[i][num_cols[t + 1]];
                        }
                    }
                }
            }
            //sort by values in descending order
            names = Object.keys(values).sort(function(a,b){return values[b]-values[a]}); 
            console.log(nextLinks);
            addNext(names, values, links, nextLinks, t);
        }
        return {
                times: times,
                links: allLinks
        };
        
    }

    //generate nodes for one col
    function addNodes(names, values, links, nextLinks, t) {
        var ncount = names.length; // number of nodes in this col
        var nodes = d3.range(0, ncount).map(function(n) {
            return {
                id: counter++,
                nodeName: names[n],
                nodeValue: values[names[n]],
                incoming: [],
                link: links[names[n]], //links coming out
                linkCount: Object.keys(links[names[n]]).length,
                targetValue: nextLinks[names[n]]
            }
        });
        times.push(nodes);
        console.log(nextLinks);
        return nodes;
    }

    function addNext(names, values, links, nextLinks, t) {
        if (t == 0) {
            addNodes(names, values, links, nextLinks, t);
            return;
        }
        var current = times[times.length - 1]; // an array of last col's nodes
        var nextt = addNodes(names, values, links, nextLinks, t);

        current.forEach(function(n) {
            var linkCount = n.linkCount;
            var link, x, i, targetid;
            for (x = 0; x < linkCount; x++) {
                //get target id:
                //this might be very inefficient
                for (i = 0; i < nextt.length; i++) {
                    if (nextt[i].nodeName == Object.keys(n.link)[x]) {
                        targetid = nextt[i].id;
                    }
                }

                link = {
                    source: n.id,
                    target: targetid, 
                    value: Object.values(n.link)[x],
                    targetValue: Object.values(n.targetValue)[x]
                };
                allLinks.push(link);
            }
        })
    }

    var dat = parse_data();

    /* Process Data */
        
    // make a node lookup map
    var nodeMap = (function() {
        var nm = {};
        dat.times.forEach(function(nodes) {
            nodes.forEach(function(n) {
                nm[n.id] = n;
                // add links and assure node value
                n.links = [];
                n.incoming = [];
                n.nodeValue = n.nodeValue || 0;
            })
        });
        return nm;
    })();

    // attach links to nodes
    dat.links.forEach(function(link) {
        nodeMap[link.source].links.push(link);
        nodeMap[link.target].incoming.push(link);
    });
        
    // sort by value and calculate offsets
    dat.times.forEach(function(nodes) {
        var cumValue = 0;
        nodes.sort(function(a,b) {
            return d3.descending(a.nodeValue, b.nodeValue)
        });
        nodes.forEach(function(n, i) {
            n.order = i;
            n.offsetValue = cumValue;
            cumValue += n.nodeValue;
            // same for links
            var lCumValue;
            // outgoing
            if (n.links) {
                lCumValue = 0;
                n.links.sort(function(a,b) {
                    return d3.descending(a.value, b.value)
                });
                n.links.forEach(function(l) {
                    l.outOffset = lCumValue;
                    lCumValue += l.value;
                });
            }
            // incoming, should use target value
            if (n.incoming) {
                lCumValue = 0;
                n.incoming.sort(function(a,b) {
                    return d3.descending(a.value, b.value)
                });
                n.incoming.forEach(function(l) {
                    l.inOffset = lCumValue;
                    lCumValue += l.targetValue;
                });
            }
        })
    });
    dat = dat.times;

    // calculate maxes
    var maxn = d3.max(dat, function(t) { return t.length }),
        maxv = d3.max(dat, function(t) { return d3.sum(t, function(n) { return n.nodeValue }) });

    /* Make Vis */
        
    // settings and scales
    var w = 1400,
        h = 500,
        gapratio = .7,
        delay = 1500,
        padding = 15,
        x = d3.scale.ordinal()
            .domain(d3.range(dat.length))
            .rangeBands([0, w + (w/(dat.length-1))], gapratio),
        y = d3.scale.linear()
            .domain([0, maxv])
            .range([0, h - padding * maxn]),
        area = d3.svg.line()
            .interpolate('monotone');
            
    // root
    var vis = d3.select("body")
      .append("svg:svg")
        .attr("width", w)
        .attr("height", h);
        
        
    var t = 0;
    function update(first) {
        // update data
        var currentData = dat.slice(0, ++t);
        
        // time slots
        var times = vis.selectAll('g.time')
            .data(currentData)
          .enter().append('svg:g')
            .attr('class', 'time')
            .attr("transform", function(d, i) { return "translate(" + (x(i) - x(0)) + ",0)" });
            
        // node bars
        var nodes = times.selectAll('g.node')
            .data(function(d) { return d })
          .enter().append('svg:g')
            .attr('class', 'node');
        
        setTimeout(function() {
            nodes.append('svg:rect')
                .attr('fill', 'steelblue')
                .attr('y', function(n, i) {
                    return y(n.offsetValue) + i * padding;
                })
                .attr('width', x.rangeBand())
                .attr('height', function(n) { return y(n.nodeValue) })
              .append('svg:title')
                .text(function(n) { return "id: ".concat(n.nodeName).concat(" freq ").concat(n.nodeValue) });
        }, (first ? 0 : delay));
            
        var linkLine = function(start) {
            return function(l) {
                var source = nodeMap[l.source],
                    target = nodeMap[l.target],
                    gapWidth = x(0),
                    nextGap = x(1),
                    bandWidth = x.rangeBand() + gapWidth,
                    startx = x.rangeBand() - bandWidth,
                    sourcey = y(source.offsetValue) + 
                        source.order * padding +
                        y(l.outOffset),
                    sourceyb = y(source.offsetValue) + 
                        source.order * padding +
                        y(l.outOffset) +
                        y(l.value),
                    targety = y(target.offsetValue) + 
                        target.order * padding + 
                        y(l.inOffset),
                    targetyb = y(target.offsetValue) + 
                        target.order * padding + 
                        y(l.inOffset) +
                        y(l.targetValue),
                    //TODO: Draw an area
                    points = start ? 
                        [
                            [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ],
                            [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ], [ startx, sourcey ]
                        ] :
                        [
                            [ startx, sourcey ],
                            [ startx, sourceyb ],
                            [ startx + gapWidth/3, sourceyb ],
                            [ startx + 2*gapWidth/3, targetyb ],

                            [ startx + gapWidth, targetyb ],

                            [ startx + gapWidth, targety ],

                            [ startx + 2*gapWidth/3, targety ],

                            [ startx + gapWidth/3, sourcey ],
                            [ startx, sourcey ],
                        ];
                    console.log(l);
                return area(points);
            }
        }
            
        // links
        var links = nodes.selectAll('path.link')
            .data(function(n) { return n.incoming || [] })
          .enter().append('svg:path')
            .attr('class', 'link')
            //.style('stroke-width', function(l) { return y(l.value) })
            .style("fill", "red")
            .attr('d', linkLine(true))
            .on('mouseover', function() {
                d3.select(this).attr('class', 'link on')  
                .append("svg:title")
                    .text(function(t) { return "src: ".concat(t.source).concat(" dest: ")
                        .concat(t.target).concat(" freq: ").concat(t.value) })
            })
            .on('mouseout', function() {
                d3.select(this).attr('class', 'link')
            })
          .transition()
            .duration(delay)
            .attr('d', linkLine());
            
    }

    function updateNext() {
        if (t < dat.length) {
            update();
            window.setTimeout(updateNext, delay)
        }
    }
    update(true);
    updateNext();
  
});
    
    </script>
  </body>
</html>
